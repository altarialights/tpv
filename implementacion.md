# Lista de tecnologías e implementación

**Sistema de carpetas**
Para el sistema de carpetas, cuando se inicie la app en el backend hay que dar la referencia de donde está la carpeta raíz donde van los archivos. Si no la hay porque es la primera vez que se incia pues desde el backend se crea. Una vez dentro de ella habría que ir creando las subcarpetas que hagan falta, ya se irá viendo según se desarolla. El nombre de la carpeta raíz y la referencia que hay que buscar es el que pongamos en el identifier en src-tauri/tauri.conf.json

**Imágenes**
Las imágenes irán en una subcarpeta dentro del directorio principal que creemos luego en la carpeta roaming. Para el guardado sería una vez el usuario introduce la imagen, con un lector con JavaScript sacamos un String base64, y generamos un uuid, y le pasamos Rust un objeto con estas dos cosas. En Rust decodifícaríamos el String base64, y pondríamos este uuid como nombre del archivo para guardarlo en la base de datos. Luego para leer desde el frontend, tauri tiene una funcionalidad nativa para poder leer archivos que estén en el sistema operativo (de forma normal los navegadores no pueden acceder a rutas de Windows/Linux/MacOS), así que obtendríamos el nombre del archivo desde la base de datos y, luego con la ruta de la carpeta donde estén las imágenes se buscaría ahí la imagen para mostrarla

**Distribución del sofware y gestión de la licencia**
Lo primero sería hacer que cada código de activación/licencia de la aplicación solo se pueda usar una vez por cada ordenador (sería como una clave oem de las que se venden de Windows/Office), para ello Tauri tiene un plugin para leer el número de serie de placa o procesador. Cuando un usuario introduzca en su ordenador la clave que le mande Lemon Squeezy cuando lo compre, desde la app se mandará una petición a la api de lemon squeezy, en la que irá la clave de activación que han metido en el ordenador, el número de serie que hemos dicho antes, y también el nombre pues del bar o de la persona o como sea (no se ahora exactamente el que). Una vez hecho esto, la api de lemon squeezy nos va a devolver un objeto json con los datos de la licencia y la fecha de expiración. Esto lo guardaríamos desde Rust en el administrador de credenciales de Windows, y bueno cada vez que se inicie la aplicación tendría que comprobar si la licencia sigue activa y es válida (para esto no hace falta internet por eso guardamos la licencia en local, pero para renovarla si haría falta). El programa debería comprobar siempre en local el token este en el arranque, aunque luego si hay wifi lo haga también a ver si es igual en la nube, pero que no lo haga en el arranque, que funcione una vez la aplicación ya esté bien al completo porque si hay algún fallo de internet o algo es una jodienda

**Generación automática de base de datos en la nube en Turso cuando alguien nuevo use el software**
Lo primero que necesitamos es un webhook en Lemon Squeezy que se dispare cuando alguien nuevo se registre en nuestro software y compre una licencia. Una vez ocurra esto, tenemos que tener una serverless function que se ejecute cuando se lo mande el webhook, y dentro tenemos que tener un script que contenga la lógica de la creación de una base de datos nueva usando la api de Turso, y generar pues la url el token y todo lo necesario, para no tener que crear todo a mano. El tema de la serverless function creo que se puede hacer de forma gratuita en algún hosting o algo así, no se necesita un servidor entero para esto.

**Tpv en cocina o en dipositivo móvil del camarero**
Aquí tenemos que hacer que la tpv principal (normalmente la de la barra), levante un servidor local a través de su ip (Ejemplo: 192.168.1.10:30000) con un puerto designado para que los demás dispositivos puedan acceder a ella, pero hay que tener cuidado con el firewall, porque cuando el programa intente escuchar en el puerto x, le va a decir que si quiere permitir que el ordenador se comunique en la red x, si lo rechazan, no vamos a poder acceder por ip como en el ejemplo a la tpv principal. Para solucionar hay que hacer que el instalador añada una regla al firewall de windows cuando se vaya a instalar la app

**Release de nuevas versiones del programa (relacionado con la base de datos)**
Hay un problema si sacamos una actualización del programa que implique añadir campos a las tablas que ya tenemos hechas, porque en el schema.sql tenemos create table if not exists, así que si añadimos el crear un nuevo campo, nunca se va a crear porque esa tabla ya existía entonces ese bloque no se ejecuta (a no ser que se instale la app de cero pero suponemos que ya estaba instalada). Entonces para solucionar esto habría que tener un control de versiones de la base de datos dentro de Rust que compruebe en que versión de la base de datos estamos, si estamos en la

**Impresión de los tickets**
Tauri tiene un plugin para poder mandar cosas a la impresora, entonces lo que tenemos que hacer es un diseño del ticket con html y con html2canvas hacemos una captura de pantalla del ticket, la convertimos a un string base64 y se imprime eso. Hay que testear cuando tarda en sacar el ticket porque es una imagen, si tarda yo que se 10 segundos pues no me parece viable, habría que mandar instrucciones crudas a la impresora para que imprima texto puro y no una imagen, pero bueno probamos lo otro primero que es más sencillo

**Problema de no tener la app verificada**
Las licencias para las aplicaciones valen entre 200 y 400 euros al año según el gemini, si se intenta instalar una aplicación que no tiene la licencia esta pues te salta lo de windows protegió su pc porque la aplicación es de origen desconocido, aunque si que se puede instalar igualmente. Supongo que si vamos nosotros personalmente a instalar el programa pues simplemente aceptas y fuera, pero si lo instala alguien desde su casa pues si le salta el aviso y no tiene ni idea va a decir esto es un virus.

**Actualizaciones de la app**
Necesitamos un sistema para poder implementar las actualizaciones de la app, porque no es viable que alguien se tenga que descargar otra vez el exe desde internet y pierda sus datos y eso. Para solucionar esto tenemos que tener lo primero un bucket en la nube que contenga los .exe que vamos sacando con las actualizaciones. En este bucket tenemos que tener un latest.json que tenga las versiones del programa con en enlace donde se encuentra. El programa luego tiene que abrir un enlace que le lleve al bucket que tenemos para que lea el json y compruebe la firma, y si ve que está desactualizado el programa lo tiene que notificar y si se acepta pues el programa tiene que reinstalar el exe encima de lo que ya hay (no se pierden los datos porque tenemos una carpeta appdata con todo lo que tiene que cargar la app). La opción más fácil para hacer esto es usar las releases de github, que te da urls públicas para descargar las versiones del programa

**Roles**
La idea de los roles sería que el jefe tenga que iniciar sesión con correo y contraseña una vez a la semana por ejemplo (o el tiempo que le queramos dar), para esto utilizaríamos Clerk por ejemplo que es muy seguro y fácil de usar. Después para el resto hay varias opciones, podemos hacer que tengas que seleccionar el rol, dentro del rol los trabajadores que hay, y luego cuando eliges el que quieres introduces el pin que tiene esa persona. También podemos directamente que cuando pongas el pin en la tpv ya sepa quien eres (Ejemplo: 1234 -> Manolo-Camarero) y te abra la interfaz correspondiente dependiendo de quien haya puesto el pin. Para la cocina no veo viable poner el tema del pin, porque lo mejor es que alguien que trabaja con las manos no esté tocando a cada rato una pantalla de una tablet, así que deberá tener las menores interacciones posibles. Y bueno para definir lo roles sería en la propia tabla de la base de datos. Para manejar las cosas en la tpv simplemente recogemos el pin donde lo introduzca el usuario, averiguamos quien es y que rol tiene, y dependiendo de eso cambiamos el estado de una variable y redirigmos a la ruta que debamos dependiendo del rol que tenga. Para poder sacar el rol sin tener que pasar props infinitas entre componentes hay que hacer un estado global y un custom hook para acceder a él rapidamente.
